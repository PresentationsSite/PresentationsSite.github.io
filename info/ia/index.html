<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
<title>IA</title>


<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <link rel="stylesheet" href="/reveal-js/css/reset.css">
<link rel="stylesheet" href="/reveal-js/css/reveal.css"><link rel="stylesheet" href="/reveal-js/css/theme/sky.css" id="theme">
<link rel="stylesheet" href="/highlight-js/atom-one-dark-reasonable.min.css">
    <link rel="stylesheet" href="/css/styles.css">

<script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
  </head>
  <body>
    
    <div class="reveal">
      <div class="slides">
  

    <section><h1 id="ia">IA</h1>
</section><section>
<p>L'<strong>intelligence arificielle</strong> (IA) est une discipline  scientifique qui a vu officiellement le jour en 1956.</p>
<p>Elle repose sur la conjecture selon laquelle toutes les fonctions cognitives, en particulier l&rsquo;apprentissage, le raisonnement, le calcul,<br>la perception, la m√©morisation, voire la d√©couverte scientifique ou la cr√©ativit√© artistique, peuvent<br>√™tre reproduites sur des ordinateurs.</p>
</section><section>
<p>L'<strong>apprentissage automatique</strong> (Machine Learning) est √† l&rsquo;intersection de l&rsquo;IA et d&rsquo;un autre champ scientifique : la science des donn√©es (data science).</p>
</section>

<section data-noprocess data-shortcode-slide
      data-background-image="/vennia.png"
      data-background-size="70%"
      data-background-transition="concave">
  
</section><section>
<p>En pratique, il s&rsquo;agit de produire des r√©ponses adapt√©es aux donn√©es fournies en entr√©e (identifier des motifs, des tendances, construire des mod√®les, faire des pr√©dictions).</p>
<p>L&rsquo;apprentissage automatique n&rsquo;est donc ni plus ni moins que du traitement de donn√©es visant √† pr√©dire des r√©sultats en fonction<br>des donn√©es entrantes.</p>
</section><section>
<br>
<div style=" position: relative;overflow: hidden;max-width: max(100%,900px);margin: auto; padding-bottom: min(100%,900px);"> 
<iframe width="900" height="800" frameborder="0" scrolling="no" src="//plotly.com/~Chinasky/10.embed"></iframe>
</div>
</section>

<section data-noprocess data-shortcode-slide
      data-background-image="https://i.vas3k.ru/7w1.jpg"
      data-background-size="60%"
      data-background-transition="concave">
  
</section><section>


<section data-shortcode-section>
<h4 id="exemple-dapprentissage-supervis√©-">Exemple d&rsquo;apprentissage supervis√© :</h4>
<h2 id="algorithme-des-kbrplus-proches-voisins">Algorithme des K<br>plus proches voisins</h2>
</section><section>
<p>KNN est un algorithme d‚Äô<strong>apprentissage supervis√©</strong> cela signifie que l‚Äôalgorithme n√©cessite<br>des donn√©es classifi√©es en amont qui vont lui servir √† trouver la bonne √©tiquette pour<br>d‚Äôautres donn√©es non encore classifi√©es.</p>
</section><section>
<p>Suivant la nature de l‚Äô√©tiquette, KNN peut servir √† :</p>
<ul>
<li>une classification des nouvelles donn√©es<br>si les √©tiquettes sont des catagories ;</li>
<li>une r√©gression si les √©tiquettes<br>sont des nombres.</li>
</ul>
</section><section>
<p>KNN enregistre, dans un premier temps, tous les points de donn√©es √©tiquet√©es qui vont lui servir √† l&rsquo;apprentissage (c&rsquo;est le training set).</p>
<p>Puis, quand arrive un point de donn√©e non √©tiquet√©, l&rsquo;algorithme calcule sa distance aux autres points et s√©lectionne les <strong>k</strong> plus proches.</p>
<p>On a alors deux cas possibles :</p>
</section><section>
<ul>
<li>
<p>si les √©tiquettes sont des cat√©gories, l&rsquo;algorithme calcule <strong>le mode</strong> des cat√©gories des voisins s√©lectionn√©s (cat√©gorie la plus repr√©sent√©e).</p>
</li>
<li>
<p>si les √©tiquettes sont des nombres, l&rsquo;algorithme calcule <strong>la moyenne</strong> des √©tiquettes des voisins s√©lectionn√©s.</p>
</li>
</ul>
</section><section>
<p>Dans l&rsquo;animation suivante, on utilise KNN pour r√©pondre √† la question suivante :</p>
<p>Quelle est la couleur du nouveau point ?</p>
</section>
<section data-noprocess data-shortcode-slide
      data-background-size="100%"
      data-background-transition="concave"
      data-background-video="/knnvid.mp4">
</section><section>
<p>L&rsquo;algorithme des <em>k</em> plus proches voisins<br>est <strong>non param√©trique</strong>.</p>
<p>Aucun mod√®le math√©matique de classification ou r√©gression n&rsquo;est construit √† partir des donn√©es<br>(pas de param√®tre √† ajuster).</p>
<p>Les donn√©es d&rsquo;apprentissage<br>sont enregistr√©es telles quelles.</p>
</section><section>
<p>Cela signifie qu&rsquo;on ne pr√©suppose rien de particulier sur les donn√©es (√† part que des points proches appartiennent √† la m√™me cat√©gorie).</p>
<p>L&rsquo;algorithme est donc particuli√®rement<br>robuste (les donn√©es parlent d&rsquo;elles-m√™me)<br>et simple √† mettre √† jour (suffit d&rsquo;ajouter<br>les nouvelles donn√©es d&rsquo;apprentissage).</p>
</section><section>
<p>Le <strong>choix de k</strong> modifie le r√©sultat obtenu.</p>
<ul>
<li>Si <em>k</em> est trop petit, le moyennage est faible et donc la variabilit√© va √™tre tr√®s grande. On parle alors de surapprentissage (<strong>overfitting</strong>).</li>
</ul>
</section><section>
<ul>
<li>En augmentant <em>k</em>, les r√©sultats obtenus se stabilisent (vote de la majorit√©) et les erreurs diminuent, jusqu&rsquo;au moment o√π la boule √† l&rsquo;int√©rieur de laquelle se fait le moyennage devient trop grosse, amenant in fine l&rsquo;algorithme a choisir syst√©matiquement la cat√©gorie majoritaire, quel que soit le point&hellip; On augmente alors le <strong>biais</strong> (ici, le biais est le pr√©judice en faveur du plus grand nombre). L&rsquo;ajustement ne suit plus les variations, on parle de sous-apprentissage (<strong>underfitting</strong>).</li>
</ul>
</section>
<section data-noprocess data-shortcode-slide
      data-background-image="/tabloverfit.png"
      data-background-size="90%"
      data-background-transition="concave">
</section><section>
<p>Le choix de <em>k</em> est donc affaire de compromis. Pour le rendre plus scientifique, on peut chercher √† mesurer la performance de l&rsquo;algorithme pour diff√©rentes valeurs de <em>k</em>.</p>
<p>Mais comment mesure-t-on la <strong>performance d&rsquo;un algorithme d&rsquo;apprentissage automatique</strong>¬†?</p>
</section><section>
<p>La <strong>matrice de confusion</strong> permet d&rsquo;√©valuer<br>la qualit√© des pr√©dictions d&rsquo;un algorithme.</p>
<p>Utilisons KNN sur une banque d&rsquo;images de chiffres √©crits √† la main et concentrons-nous sur<br>sa capacit√© √† reconna√Ætre des &ldquo;3&rdquo;.</p>
</section>
<section data-noprocess data-shortcode-slide
      data-background-image="/MnistExamples.png"
      data-background-size="70%"
      data-background-transition="concave">
</section>
<section data-noprocess data-shortcode-slide
      data-background-image="/matconfus.png"
      data-background-size="60%"
      data-background-transition="concave">
</section><section>
<p>Un algorithme peut tr√®s bien √™tre <strong>tr√®s pr√©cis</strong><br>(les pr√©dictions positives sont bien des 3),<br>mais <strong>peu sensible</strong>, avec un faible taux de rappel (parmi tous les 3, peu ont √©t√© identifi√©s).</p>
</section><section>
<p>√Ä l&rsquo;inverse, on peut avoir une <strong>bonne sensibilit√©</strong><br>(la plupart des vrais 3 ont √©t√© identifi√©s comme tel), mais <strong>peu pr√©cis</strong> (beaucoup de chiffres identifi√©s comme des 3 sont en fait d&rsquo;autres chiffres).</p>

</section>
</section><section>


<section data-shortcode-section>
<h4 id="exemple-dapprentissage-non-supervis√©-">Exemple d&rsquo;apprentissage non-supervis√© :</h4>
<h2 id="algorithme-desbrk-moyennes">Algorithme des<br>K-moyennes</h2>
</section><section>
<p>L&rsquo;algorithme des k-moyennes regroupe<br>en cat√©gories des donn√©es<br><em>dont on ne conna√Æt rien a priori</em>.</p>
<br>
<p>C&rsquo;est un algorithme<br>de <strong>partitionnement</strong><br>des donn√©es (clustering).</p>
</section><section>
<p>L&rsquo;algorithme depend d&rsquo;un seul param√®tre<br>(en plus des donn√©es) :<br>le nombre de partitions <em>k</em>.</p>
</section><section>
<ul>
<li>
<p>On commence par choisir <em>k</em> points au hasard dans l&rsquo;espace des donn√©es (il peut s&rsquo;agir de <em>k</em> points de donn√©es ou de <em>k</em> autres points). Ce sont les <em>k</em> centres (ou centro√Ødes).</p>
</li>
<li>
<p>On attribue ensuite √† chaque centre tous les points de donn√©es qui lui sont le plus proches, formant ainsi <em>k</em> groupes.</p>
</li>
<li>
<p>Enfin, on d√©place chaque centre au barycentre de son groupe.</p>
</li>
</ul>
</section><section>
<p>On r√©p√®te les deux derni√®res op√©rations (attribution des points les plus pr√®s<br>et d√©placement des centres)<br>tant que les centres bougent<br>d&rsquo;une it√©ration √† l&rsquo;autre.</p>
</section>
<section data-noprocess data-shortcode-slide
      data-background-size="100%"
      data-background-transition="concave"
      data-background-video="/vidkmean.mp4">
</section><section>
<p>L&rsquo;algorithme vise √† r√©soudre au final un probl√®me d&rsquo;optimisation ; son but est en effet de trouver le minimum de la distance entre les points √† l&rsquo;int√©rieur de chaque partition.</p>
</section><section>
<p>Math√©matiquement, √©tant donn√© un ensemble<br>de points $(x_1,x_2,\ldots,x_n)$, on cherche √† partitionner les $n$ points en $k$ ensembles $S=\{S_1,S_2,\ldots,S_k\}$ en minimisant la grandeur
$$I = \sum_{i=1}^{k}\sum_{x_j \in S_i}||x_i-\mu_i||^2$$
o√π $\mu_i$ est le barycentre des points dans $S_i$.</p>
<p>$I$ est la variance intra-classe ou <strong>inertie</strong> intra-classe (terme surtout utilis√© en anglais).</p>
</section><section>
<h3 id="choix-de-k">Choix de k</h3>
</section>
<section data-noprocess data-shortcode-slide
      data-background-image="/choixdek.png"
      data-background-size="100%"
      data-background-transition="concave">
</section>
<section data-noprocess data-shortcode-slide
      data-background-image="/inertiefctk3.png"
      data-background-size="80%"
      data-background-transition="concave">
</section>
<section data-noprocess data-shortcode-slide
      data-background-image="/inertiefctk5.png"
      data-background-size="100%"
      data-background-transition="concave">
</section><section>
<h3 id="limites">Limites</h3>
</section>
<section data-noprocess data-shortcode-slide
      data-background-image="/localglobal.png"
      data-background-size="60%"
      data-background-transition="concave">
</section>
<section data-noprocess data-shortcode-slide
      data-background-image="/subopti.png"
      data-background-size="26%"
      data-background-transition="concave">

</section>
</section><section>


<section data-shortcode-section>
<h2 id="jeux-daccessibilit√©brsur-un-graphe">Jeux d&rsquo;accessibilit√©<br>sur un graphe</h2>
<p>On quitte l&rsquo;apprentissage automatique<br>mais on reste dans le champ de l&rsquo;IA.</p>
</section><section>
<p><u>Vocabulaire</u></p>
<p>On entendra ici par jeu :</p>
<ul>
<li>des jeux √† deux joueurs<br>($J_1$ et $J_2$ ou Eve et Adam)</li>
<li>√† <strong>information compl√®te</strong>¬†: les deux joueurs savent tout (pas comme aux cartes)</li>
<li><strong>altern√©s</strong> (pas comme √† chifoumi)</li>
<li><strong>non randomis√©s</strong> (pas de hasard)</li>
</ul>
</section><section>
<p>L'<strong>ar√®ne</strong> dans laquelle le jeu prend place<br>est un <strong>graphe orient√© biparti</strong>.</p>
<div style="color:gray;text-align:left">
Un graphe biparti (ou bipartite) $G$ est un graphe dont l'ensemble des sommets peut √™tre divis√© en deux sous-ensembles de sommets disjoints $S_1$ et $S_2$ ($S_1$ et $S_2$ sont une partition de $S$&nbsp;: $S_1\cup S_2=S$, $S_1\cap S_2=\varnothing$) tels que chaque ar√™te de $G$ a une extr√©mit√© dans $S_1$ et l'autre dans $S_2$.
</div>
</section>
<section data-noprocess data-shortcode-slide
      data-background-image="/animbipar.gif"
      data-background-size="100%"
      data-background-transition="concave">
</section><section>
<p>Deux joueurs, $J_1$ et $J_2$, s&rsquo;affrontent sur un graphe orient√© biparti $G=(S,A)$ o√π $S$ est constitu√© des sommets contr√¥l√©s par le joueur 1, $S_1$, et de ceux contr√¥l√©s par le joueur 2, $S_2$. Chaque sommet est une position valide du jeu et chaque ar√™te est un mouvement autoris√© entre ces positions.</p>
</section><section>
<p>Dans le cas d&rsquo;un <strong>jeu d&rsquo;accessibilit√©</strong>, on attribue √† chaque joueur un sous-ensemble de sommets correspondant √† des √©tats gagnants qu&rsquo;il doit atteindre pour&hellip; gagner.</p>
<p>Il peut aussi exister un sous-ensemble de sommets correspondant √† des √©tats de partie nulle.</p>
</section><section>
<p>Un jeu d&rsquo;accessibilit√© est alors d√©fini<br>par un quadruplet $(G,S_1,S_2,F)$</p>
<p>o√π $(G,S_1,S_2)$ est une ar√®ne et $F$ est l&rsquo;ensemble des sommets gagnants pour $J_1$.</p>
</section><section>
<h3 id="exemples">Exemples</h3>
</section>
<section data-noprocess data-shortcode-slide
      data-background-size="100%"
      data-background-transition="concave"
      data-background-video="/chompintro.mp4">
</section>
<section data-noprocess data-shortcode-slide
      data-background-image="/arenechomp.png"
      data-background-size="60%"
      data-background-transition="concave">
</section><section>
<p><strong>Autre variante du jeu de Nim :</strong></p>
<p>Eve joue en premier et peut retirer autant d‚Äôallumettes qu‚Äôelle le souhaite dans un tas<br>du moment qu‚Äôelle en prend au moins une<br>et qu‚Äôelle en laisse au moins une.</p>
</section><section>
<p>C‚Äôest ensuite au tour d‚ÄôAdam de retirer des allumettes avec pour tous les tours qui suivent<br>une contrainte suppl√©mentaire :</p>
<p>on ne peut pas retirer plus de deux fois le nombre d‚Äôallumettes prises par son adversaire<br>au tour pr√©c√©dent.</p>
</section><section>
<p>Le joueur qui retire la derni√®re allumette gagne.<br>Il n‚Äôy a pas de match nul.</p>
</section><section>
<p>En commen√ßant avec un tas de 5 allumettes,<br>on obtient l&rsquo;ar√®ne suivante</p>
<p>o√π chaque sommet est √©tiquet√© par le couple<br>(nombre d&rsquo;allumettes pr√©sentes,<br>nombre d&rsquo;allumettes prenables).</p>
</section>
<section data-noprocess data-shortcode-slide
      data-background-image="/variantenim.png"
      data-background-size="60%"
      data-background-transition="concave">
</section><section>
<p>L&rsquo;ar√®ne s&rsquo;√©crit donc :</p>
<p>$$
\begin{aligned}
&amp;(G,\color{blue}\{(5,4,0),(3,2,0),(2,2,0),(1,1,0),(0,0,0)\}\color{black},\\<br>
&amp;\color{magenta}\{(4,2,1),(3,3,1),(2,2,1),(1,1,1),(0,0,1)\}\color{black},\color{orange}(0,0,1)\color{black})
\end{aligned}
$$</p>
</section><section>
<p><u>Remarque</u></p>
<p>Tout jeu impartial √† deux joueurs est une variante du jeu de Nim (th√©or√®me de Sprague-Grundy).</p>
</section><section>
<div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
  <iframe src="https://www.youtube.com/embed/2jahbr5wMHk" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" allowfullscreen title="YouTube Video"></iframe>
</div>
</section><section>
<p>Un <strong>jeu impartial</strong> est un jeu tour par tour dans lequel les coups autoris√©s, ainsi que les gains obtenus, d√©pendent uniquement de la position,<br>et pas du joueur dont c&rsquo;est le tour.</p>
<p>Un jeu qui n&rsquo;est pas impartial est appel√© <strong>jeu partisan</strong> (le morpion ou les √©checs par exemple).</p>
</section><section>
<p><strong>Le morpion :</strong></p>
<p>On part ici d&rsquo;une partie avanc√©e.</p>
<p>Eve a les ronds et c&rsquo;est son tour.</p>
</section>
<section data-noprocess data-shortcode-slide
      data-background-image="/graphetictac1.png"
      data-background-size="60%"
      data-background-transition="concave">
</section><section>
<h3 id="mise-au-point-dune-strat√©gie-gagnante-pour-eve">Mise au point d&rsquo;une strat√©gie gagnante pour Eve</h3>
</section><section>
<p>Il faut pouvoir s&rsquo;assurer qu&rsquo;Eve arrive sur $F$.</p>
<p>Comment faire ?</p>
</section><section>
<p><strong>Positions gagnantes et attracteurs</strong></p>
<p>Pour d√©terminer l&rsquo;ensemble des positions gagnantes pour Eve sur l&rsquo;ar√®ne, on travaille r√©cursivement depuis les sommets de $F$<br>en suivant les deux pr√©ceptes suivants¬†:</p>
</section>
<section data-noprocess data-shortcode-slide
      data-background-image="/sommetgagnant1.png"
      data-background-size="20%"
      data-background-transition="concave">
<ul>
<li>un sommet d&rsquo;Eve est gagnant si <strong>un</strong> de ses arcs sortants le lie √† un sommet gagnant.<br>
Eve n&rsquo;a alors plus qu&rsquo;√† emprunter ce chemin.<br></li>
</ul>
<p><br><br><br><br><br><br></p>
</section>
<section data-noprocess data-shortcode-slide
      data-background-image="/sommetgagnant2.png"
      data-background-size="20%"
      data-background-transition="concave">
<ul>
<li>un sommet d&rsquo;Adam est gagnant (pour Eve)<br>si <strong>tous</strong> ses arcs sortants le lie √† un sommet gagnant.<br>
En effet, Adam ne peut alors pas √©viter de mettre Eve dans une position gagnante.</li>
</ul>
<p><br><br><br><br><br><br></p>
</section><section>
<p>Formalisons en d√©finissant la suite $Attr_i(F)$<br>qui contient l&rsquo;ensemble des sommets<br>gagnants apr√®s $i$ √©tapes¬†:</p>
<p>$$ \begin{array}{lll} Attr_0(F) &amp;= &amp;F \\  Attr_{i+1}(F) &amp;= &amp;Attr_{i}(F) \\ &amp;&amp;\cup \{s \in S_1|Succ(s)\cap Attr_i(F) ‚â† \varnothing \} \\ &amp;&amp;\cup \{s\in S_2| Succ(s)\subseteq Attr_i(F)\} \end{array} $$</p>
</section><section>
<p>√âtant donn√© que $Attr_i(F) \subseteq Attr_{i+1}(F) \subseteq S$, pour tout $i‚â•0$, si on suppose le graphe fini,<br>la suite est croissante et born√©e<br>et donc stationnaire<br>(√† partir d&rsquo;un certain $i=i_0$,<br>$Attr_i(F)$ est constante).</p>
<p>Et si $|G|=n$, $i_0$ vaut au plus $n-1$.</p>
</section><section>
<p>On appelle <strong>attracteur</strong> de $F$ pour le joueur $J_1$<br> la limite de $Attr_i(F)$.</p>
<p>On le note $Attr(F)$.</p>
<p>Tout sommet dans l&rsquo;attracteur<br>est une <strong>position gagnante</strong> pour $J_1$.</p>
</section><section>
<p>Le compl√©mentaire d&rsquo;un attracteur<br>est appel√© <strong>pi√®ge</strong>.</p>
</section><section>
<p>Si le joueur 1 est sur une position n&rsquo;appartenant pas √† son attracteur (et appartenant<br>donc √† son pi√®ge), cela signifie que :</p>
<ul>
<li>si c&rsquo;est son tour, tous les mouvements possibles restent dans le pi√®ge,</li>
<li>si c&rsquo;est le tour de l&rsquo;adversaire, celui-ci a toujours au moins une possibilit√© de laisser le joueur 1 dans le pi√®ge.</li>
</ul>
<p>Cette position est donc perdante&hellip;</p>
</section>
<section data-noprocess data-shortcode-slide
      data-background-size="100%"
      data-background-transition="concave"
      data-background-video="/chompattract.mp4">
</section><section>
<p>Dans le cas de la variante de Nim, l&rsquo;attracteur se r√©duit √† $Attr(G) = \{(0,0,1) , (1,1,0) , (2,2,0) \}$</p>
<p>Le sommet de d√©part $(5,4,0)$ n&rsquo;est pas dedans<br>$\Rightarrow$ c&rsquo;est perdu pour Eve üò≠.</p>
</section>
<section data-noprocess data-shortcode-slide
      data-background-image="/nimvarattr.png"
      data-background-size="70%"
      data-background-transition="concave">
</section><section>
<p>Sur l&rsquo;exemple du morpion, l&rsquo;attracteur contient<br>13 sommets dont celui de d√©part ü•≥.</p>
</section>
<section data-noprocess data-shortcode-slide
      data-background-size="100%"
      data-background-transition="concave"
      data-background-video="/morpionattr.mp4">
</section><section>
<p><strong>Programme permettant de calculer l&rsquo;attracteur</strong></p>
</section><section>
<p>On peut √©crire un programme r√©cursif calculant l&rsquo;attracteur en temps lin√©aire en $|S | + |A|$ <br>(le parcours complet d&rsquo;un graphe est au mieux en $O(|S | + |A|)$ car cela correspond √† parcourir<br>les $|S|$ sommets et les $|A|$ ar√™tes).</p>
<p>Pour √©viter de calculer plusieurs fois le m√™me √©l√©ment, l&rsquo;algorithme tient √† jour, pour chaque sommet $s$, un compteur <code>n</code> des successeurs non encore inspect√©s (sous la forme d&rsquo;un dictionnaire) .</p>
</section><section>
<pre><code class="language-python">def attracteur(G: dict, F: list) -&gt; list:
    &quot;&quot;&quot;
    pr√©conditions : G est est un graphe sous forme de liste d'adjacence impl√©ment√©e par un dictionnaire
                    F est la liste des sommets gagnants pour le joueur 1
    postcondition : la fonction retourne l'attracteur de F pour le joueur 1 sous forme d'un dictionnaire
                    dont les cl√©s sont les sommets de G et les valeurs True ou False suivant que le sommet appartienne ou non √† l'attracteur
    &quot;&quot;&quot;
    Pred = inverseGraphe(G)
    n = {s:len(G[s]) for s in G}
    Attr = {s:False for s in G}
    for sommet in F :
        Joueur1 = True
        propage(sommet,Joueur1,Attr,Pred,n)
    return Attr

def propage(sommet,Joueur1,Attr,Pred,n) :
    if Attr[sommet] :
        return
    Attr[sommet] = True
    for s in Pred[sommet] :
        n[s] -= 1
        if Joueur1 or (n[s] == 0) :
            propage(s,not Joueur1,Attr,Pred,n)
</code></pre>
</section><section>
<h3 id="strat√©gie-sans-m√©moire-gagnante">Strat√©gie sans m√©moire gagnante</h3>
</section><section>
<p>Une <strong>strat√©gie sans m√©moire</strong> est une fonction $\sigma$ qui assigne un mouvement autoris√© √† un joueur pour chaque position non terminale¬†: $\forall s\in S, (s,\sigma(s))\in A.$</p>
<p>Un joueur sur une position $s$ suit une strat√©gie s&rsquo;il emprunte le chemin $&lt;s,\sigma(s),\sigma^2(s),\ldots&gt;$.</p>
<p>Elle est dite <strong>sans m√©moire</strong> car pour une position donn√©e, la strat√©gie est ind√©pendante du chemin qui y a men√© ($\sigma$ ne d√©pend que du sommet).</p>
</section><section>
<p>Une <strong>strat√©gie sans m√©moire gagnante</strong> depuis une position donn√©e garantit la victoire au joueur en un nombre de coups limit√©.</p>
<p>Pour le joueur 1, une strat√©gie gagnante garantit d&rsquo;arriver sur un sommet de $F$.</p>
<p>Mais suivant la position de d√©part, une telle strat√©gie n&rsquo;existe pas forc√©ment&hellip;</p>
</section><section>
<p>En construisant l&rsquo;attracteur,<br>on r√©pond √† notre premi√®re question¬†:</p>
<p>La <strong>position</strong> d&rsquo;Eve est-elle <strong>gagnante</strong>¬†?<br>$\rightarrow$ Il suffit de v√©rifier qu&rsquo;elle<br><strong>appartient √† l&rsquo;attracteur</strong>.</p>
<p>Si c&rsquo;est le cas, une strat√©gie gagnante est facile √† mettre en place¬†; il faut faire en sorte que chaque d√©placement sur le graphe (chaque coup jou√©) se fasse vers un sommet de l&rsquo;attracteur. Chaque coup d&rsquo;Eve vers un sommet de l&rsquo;attracteur pi√®ge aussi le coup suivant d&rsquo;Adam dans l&rsquo;attracteur.</p>
</section><section>
<p>Comme son nom l&rsquo;indique, l&rsquo;attracteur attire irr√©m√©diablement vers $F$,<br>assurant la victoire<br> au joueur 1.</p>
</section><section>
<p>Le joueur 2 aussi, bien s√ªr, a son attracteur,<br>et il appartient au compl√©mentaire de l&rsquo;attracteur du joueur 1, pi√®ge du joueur 1.</p>
<p>Donc un seul √©cart du joueur 1 en dehors de son attracteur, et s&rsquo;en est fini pour lui, le joueur 2 peut le condanner √† rester dans le pi√®ge.</p>
</section><section>
<ul>
<li>Pour Chomp, le joueur 1 appartient √† l&rsquo;attracteur, ce qui signifie que sa position de d√©part est gagnante. Par cons√©quent, il a une strat√©gie gagnante. Mais attention √† ne pas se tromper au d√©but¬†! Sur 5 mouvements possibles, le seul assurant la victoire est de manger le carr√© en haut √† droite.</li>
</ul>
</section><section>
<ul>
<li>
<p>Pour la variante de Nim, c&rsquo;est foutu ! Quelle que soit notre strat√©gie, elle sera perdante&hellip;</p>
</li>
<li>
<p>Enfin, pour le morpion, la victoire tend les bras au joueur 1. Et, sans surprise, son premier mouvement doit √™tre de prendre<br>le milieu.</p>
</li>
</ul>

</section>
</section><section>


<section data-shortcode-section>
<h2 id="algorithme-du-minimax">Algorithme du minimax</h2>
</section><section>
<p>Algorithme star pour les jeux. C&rsquo;est ce type d&rsquo;algorithme que Deep Blue a utilis√©<br>pour battre  Kasaparov en 1997.</p>
</section>
<section data-noprocess data-shortcode-slide
      data-background-image="/Kasparov.png"
      data-background-size="contain"
      data-background-transition="concave">
</section><section>
<p>Le principe de l&rsquo;algo est proche de celui de l&rsquo;attracteur, mais il est plus souple et permet surtout de n&rsquo;explorer qu&rsquo;une petite partie de l&rsquo;ar√®ne (au d√©triment de sa performance).</p>
</section><section>
<p>Le plus grand changement par rapport au raisonnement sur l&rsquo;attracteur : on transforme<br>le graphe de l&rsquo;ar√™ne en <strong>arbre</strong>.</p>
</section>
<section data-noprocess data-shortcode-slide
      data-background-image="/morpionarbre.png"
      data-background-size="contain"
      data-background-transition="concave">
</section><section>
<ul>
<li>
<p>Avantage ?</p>
</li>
<li>
<p>Inconv√©nient ?</p>
</li>
</ul>
</section><section>
<p>Le but va √™tre de trouver un chemin entre la racine de l&rsquo;arbre et une feuille gagnante (victoire finale).</p>
</section><section>
<p>L&rsquo;id√©e est, comme pour l&rsquo;attracteur,<br>de partir de la situation finale et de remonter r√©cursivement tour par tour.</p>
<p>On score chaque feuille terminale<br>avec une valeur de $+\infty$ si le joueur 1 gagne<br>et de $-\infty$ si c&rsquo;est le joueur 2.</p>
</section><section>
<p>On remonte ensuite niveau par niveau :</p>
<ul>
<li>si c&rsquo;est le tour du joueur 1, on choisi le sommet au plus grand score (<strong>max</strong>)</li>
<li>si c&rsquo;est au joueur 2, on choisi le sommet au plus petit score (<strong>min</strong>)</li>
</ul>
<p>Chaque joueur simul√© joue bien ainsi<br>de mani√®re optimale.</p>
</section><section>
<p>L&rsquo;int√©r√™t majeur de minimax est la possibilit√©<br>de partir de n&rsquo;importe quel niveau<br>et pas seulement des positions finales !</p>
<p>On peut donce se contenter de  regarder<br>seulement quelques coups √† l&rsquo;avance.</p>
<br>
<p><span class='fragment ' ><span style="font-weight:normal">Quel est l‚Äôint√©r√™t ?</span></span></p>
</section><section>
<p>Mais pour se limiter √† une certaine profondeur dans l&rsquo;arbre, il faut pouvoir scorer<br>les sommets du niveau de d√©part !</p>
<br>
<p>On utilise alors une <strong>heuristique</strong>.</p>
</section><section>
<div style="display: flex;justify-content: center;">
<div style = "border:solid red 5px;padding: 20px 0px 30px 0px; font-size:40px">
Une heuristique est une m√©thode de calcul qui fournit rapidement une solution r√©alisable,<br><span>pas n√©cessairement optimale ou exacte</span>,<br>pour un probl√®me d‚Äôoptimisation difficile.<br>
Une heuristique est donc un compromis entre d‚Äôun c√¥t√© l‚Äôoptimalit√© (trouver la meilleure solution) et/ou la compl√©tude (trouver toutes les solutions) de l‚Äôalgorithme et de l‚Äôautre c√¥t√© sa vitesse.
</div></div>
</section><section>
<p>Exemples :</p>
<p>Au morpion, si c&rsquo;est au tour du joueur 1, on peut compter le nombre de diagonales encore possibles pour le joueur 1 et soustraire le nombre de celles encore possibles pour le joueur 2.</p>
</section>
<section data-noprocess data-shortcode-slide
      data-background-size="100%"
      data-background-transition="concave"
      data-background-video="/gifmorp.mp4">
</section><section>
<iframe src="https://trinket.io/embed/python/5a7f499742?start=result" width="100%" height="600" frameborder="0" marginwidth="0" marginheight="0" allowfullscreen></iframe>
</section><section>
<p>L&rsquo;arbre total du morpion n&rsquo;est pas si gros¬†:<br>le <strong>facteur de ramification</strong> $b$ est de 5 en moyenne et il y a au plus 9 niveaux (9 coups),<br>ce qui donne $\approx 5^9 = 1\,953\,125$</p>
<p>Aux √©checs, $b\approx35$ et un partie dure en moyenne 100 coups, ce qui donne $b^m\approx10^{54}$<br>sommets √† inspecter&hellip;</p>
</section><section>
<p>Minimax inspecte en r√©alit√© environ 4 fois moins de sommets que les deux millions pr√©dits (beaucoup de parties se terminent<br>avant le neuvi√®me coup).</p>
</section><section>
<p>Il en inspecte n√©anmoins beaucoup trop puisqu&rsquo;il n&rsquo;y a que $9!=362\,880$ coups possibles<br>si l&rsquo;ordi commence.</p>
<p>Cela illustre le fait qu&rsquo;un arbre contient beaucoup de sommets redondants par rapport au graphe<br>du jeu dont il est tir√© (c&rsquo;est le prix √† payer<br>pour casser les cycles).</p>

</section>
</section><section>


<section data-shortcode-section>
<h2 id="probl√®me-du-sac-√†-dos">Probl√®me du sac-√†-dos</h2>
</section><section>
<p>Le probl√®me du sac-√†-dos est<br>un prob√®me cl√© d&rsquo;optimisation.</p>
<p>Il s&rsquo;agit de choisir des objets ayant une certaine valeur et un certain poids pour les mettre dans<br>un sac ayant une capacit√© maximum<br>(un poids √† ne pas d√©passer).</p>
<p>On souhaite obtenir le sac de plus grande valeur.</p>
</section><section>
<p>On ne s&rsquo;occupe ici que de la version la plus simple du probl√®me dite <strong>knapsack 0-1</strong> o√π un objet est soit pr√©sent une seule fois dans le sac, soit absent.</p>
</section><section>
<p>Le probl√®me du sac-√†-dos est un probl√®me d&rsquo;optimisation sous contrainte et une foule de d√©fis scientifiques et industriels peuvent se mettre sous cette forme. Son importance est colossale.</p>
</section><section>
<p>Supposons que l&rsquo;on ait $n$ objets.</p>
<p>Un algorithme force brute consiste<br>√† √©tudier les &hellip; possibilit√©s.</p>
<p>Et d√®s qu&rsquo;il s&rsquo;agit d&rsquo;explorer un ensemble de combinaisons, la r√©cursivit√© est l&rsquo;outil de choix.</p>
</section><section>
<p>Supposons que l&rsquo;on cherche √† placer les objets suivants dans un sac de capacit√© 900.</p>
<table>
<thead>
<tr>
<th>objets</th>
<th style="text-align:center">ü•è</th>
<th style="text-align:center">üé∫</th>
<th style="text-align:center">ü•ä</th>
<th style="text-align:center">üß∏</th>
<th style="text-align:center">ü™†</th>
<th style="text-align:center">‚è∞</th>
</tr>
</thead>
<tbody>
<tr>
<td>valeurs $v$</td>
<td style="text-align:center">5</td>
<td style="text-align:center">50</td>
<td style="text-align:center">65</td>
<td style="text-align:center">20</td>
<td style="text-align:center">10</td>
<td style="text-align:center">12</td>
</tr>
<tr>
<td>poids $p$</td>
<td style="text-align:center">320</td>
<td style="text-align:center">700</td>
<td style="text-align:center">845</td>
<td style="text-align:center">180</td>
<td style="text-align:center">70</td>
<td style="text-align:center">420</td>
</tr>
</tbody>
</table>
</section>
<section data-noprocess data-shortcode-slide
      data-background-image="/arbresac.png"
      data-background-size="contain"
      data-background-transition="concave">
</section><section>
<pre><code class="language-python">def KS(v,p,c,i,valeur,poids):
    n = len(v)
    if i == n: # cas de base (i = n-i√®me objet)
        if poids &gt; c:
            return 0
        else:
            return valeur
    else:
        valeurAvec = valeur + v[i]
        poidsAvec = poids + p[i]
        return max(KS(v,p,c,i+1,valeur,poids),KS(v,p,c,i+1,valeurAvec,poidsAvec))
</code></pre>
</section>
<section data-noprocess data-shortcode-slide
      data-background-image="/arbresacsol.png"
      data-background-size="contain"
      data-background-transition="concave">
</section><section>
<p>C&rsquo;est bien s√ªr trop long si le nombre<br>d&rsquo;objets devient cons√©quent.</p>
<p>Pour acc√©l√©rer les choses, on peut se tourner vers une <strong>strat√©gie gloutonne</strong> (strat√©gie √©tape par √©tape o√π un crit√®re de classement permet de s√©lectionner le prochain objet √† ajouter).</p>
<p>La complexit√© devient alors &hellip;</p>
</section><section>
<p>Le ratio valeur/poids de chaque objet<br>semble un bon crit√®re.</p>
<table>
<thead>
<tr>
<th>objets</th>
<th style="text-align:center">ü•è</th>
<th style="text-align:center">üé∫</th>
<th style="text-align:center">ü•ä</th>
<th style="text-align:center">üß∏</th>
<th style="text-align:center">ü™†</th>
<th style="text-align:center">‚è∞</th>
</tr>
</thead>
<tbody>
<tr>
<td>ratio $v/p$</td>
<td style="text-align:center">1/64</td>
<td style="text-align:center">1/14</td>
<td style="text-align:center">1/13</td>
<td style="text-align:center">1/9</td>
<td style="text-align:center">1/7</td>
<td style="text-align:center">1/35</td>
</tr>
</tbody>
</table>
</section><section>
<p>Probl√®me : √ßa ne marche pas forc√©ment&hellip;</p>
<p>Ici, on se retrouve avec ü™† et üß∏ dans le sac<br>pour une valeur de 30‚Ç¨ ce qui n&rsquo;est<br>√©videmment pas optimal.</p>
</section><section>
<p>Une autre d√©marche consiste √† construire l&rsquo;abre binaire comme pour l&rsquo;approche force brute mais en l&rsquo;√©laguant au fur et √† mesure quand des branches ne peuvent plus donner la solution.</p>
<p>C&rsquo;est la m√©thode  ‚Äús√©paration et √©valuation‚Äù<br>(branch and bond ou BB en anglais).</p>
</section><section>
<p>Ici, deux √©lagages possibles :</p>
<ul>
<li>lorsque tout objet ajout√© d√©passe la capacit√©, pas la peine d&rsquo;aller plus loin.</li>
<li>et si la valeur maximale du sous-arbre est inf√©rieure √† la valeur trouv√©e par l&rsquo;approche gloutonne, pas la peine non plus d&rsquo;aller plus loin.</li>
</ul>
<p>On se sert donc ici de l&rsquo;approche gloutonne<br>comme d&rsquo;une &hellip;</p>
</section>
<section data-noprocess data-shortcode-slide
      data-background-image="/arbresacbb.png"
      data-background-size="contain"
      data-background-transition="concave">

</section>
</section><section>
<p><a href="https://info-tsi-vieljeux.github.io/semestre_3/tp13/">Retour site</a></p>
</section>

  


</div>
      

    </div>
<script type="text/javascript" src=/reveal-hugo/object-assign.js></script>

<a href="/reveal-js/css/print/" id="print-location" style="display: none;"></a>
<script type="text/javascript">
  var printLocationElement = document.getElementById('print-location');
  var link = document.createElement('link');
  link.rel = 'stylesheet';
  link.type = 'text/css';
  link.href = printLocationElement.href + (window.location.search.match(/print-pdf/gi) ? 'pdf.css' : 'paper.css');
  document.getElementsByTagName('head')[0].appendChild(link);
</script>

<script type="application/json" id="reveal-hugo-site-params">{"highlight_theme":"github-dark","line-numbers":true,"theme":"sky","transition":"concave","transition_speed":"fast"}</script>
<script type="application/json" id="reveal-hugo-page-params">{"highlight_theme":"atom-one-dark-reasonable"}</script>

<script src="/reveal-js/js/reveal.js"></script>

<script type="text/javascript">
  
  
  function camelize(map) {
    if (map) {
      Object.keys(map).forEach(function(k) {
        newK = k.replace(/(\_\w)/g, function(m) { return m[1].toUpperCase() });
        if (newK != k) {
          map[newK] = map[k];
          delete map[k];
        }
      });
    }
    return map;
  }
  
  var revealHugoDefaults = { center: true, controls: true, history: true, progress: true, transition: "slide" };
  var revealHugoSiteParams = JSON.parse(document.getElementById('reveal-hugo-site-params').innerHTML);
  var revealHugoPageParams = JSON.parse(document.getElementById('reveal-hugo-page-params').innerHTML);
  
  var options = Object.assign({},
    camelize(revealHugoDefaults),
    camelize(revealHugoSiteParams),
    camelize(revealHugoPageParams));
  Reveal.initialize(options);
</script>


  
  
  <script type="text/javascript" src="/reveal-js/plugin/markdown/marked.js"></script>
  
  <script type="text/javascript" src="/reveal-js/plugin/markdown/markdown.js"></script>
  
  <script type="text/javascript" src="/reveal-js/plugin/highlight/highlight.js"></script>
  
  <script type="text/javascript" src="/reveal-js/plugin/zoom-js/zoom.js"></script>
  
  
  <script type="text/javascript" src="/reveal-js/plugin/notes/notes.js"></script>









  <script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
  <script>
    mermaid.initialize({startOnLoad: false});
    let render = (event) => {
      let mermaidElems = event.currentSlide.querySelectorAll('.mermaid');
      if (!mermaidElems.length){
          return
      }
      mermaidElems.forEach(mermaidElem => {
          let processed = mermaidElem.getAttribute('data-processed');
          if (!processed){
              
              mermaid.init(undefined, mermaidElem);
          }
      });
    };
    Reveal.addEventListener('slidechanged', render);
    Reveal.addEventListener('ready', render);
  </script>

    

<script>
MathJax = {
  tex: {
    inlineMath: [['$', '$'], ['\\(', '\\)']]
  },
  svg: {
    fontCache: 'global'
  }
};
</script>

<script type="text/javascript" id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js">
</script>
    
  </body>
</html>
