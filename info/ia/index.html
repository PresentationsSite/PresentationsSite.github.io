<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
<title>IA</title>


<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <link rel="stylesheet" href="/reveal-js/css/reset.css">
<link rel="stylesheet" href="/reveal-js/css/reveal.css"><link rel="stylesheet" href="/reveal-js/css/theme/sky.css" id="theme">
<link rel="stylesheet" href="/highlight-js/atom-one-dark-reasonable.min.css">
    <link rel="stylesheet" href="/css/styles.css">

<script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
  </head>
  <body>
    
    <div class="reveal">
      <div class="slides">
  

    <section><h1 id="ia">IA</h1>
</section><section>
<p>L'<strong>intelligence arificielle</strong> (IA) est une discipline  scientifique qui a vu officiellement le jour en 1956.</p>
<p>Elle repose sur la conjecture selon laquelle toutes les fonctions cognitives, en particulier l&rsquo;apprentissage, le raisonnement, le calcul,<br>la perception, la mémorisation, voire la découverte scientifique ou la créativité artistique, peuvent<br>être reproduites sur des ordinateurs.</p>
</section><section>
<p>L'<strong>apprentissage automatique</strong> (Machine Learning) est à l&rsquo;intersection de l&rsquo;IA et d&rsquo;un autre champ scientifique : la science des données (data science).</p>
</section>

<section data-noprocess data-shortcode-slide
      data-background-image="/vennia.png"
      data-background-size="70%"
      data-background-transition="concave">
  
</section><section>
<p>En pratique, il s&rsquo;agit de produire des réponses adaptées aux données fournies en entrée (identifier des motifs, des tendances, construire des modèles, faire des prédictions).</p>
<p>L&rsquo;apprentissage automatique n&rsquo;est donc ni plus ni moins que du traitement de données visant à prédire des résultats en fonction<br>des données entrantes.</p>
</section><section>
<br>
<div style=" position: relative;overflow: hidden;max-width: max(100%,900px);margin: auto; padding-bottom: min(100%,900px);"> 
<iframe width="900" height="800" frameborder="0" scrolling="no" src="//plotly.com/~Chinasky/10.embed"></iframe>
</div>
</section>

<section data-noprocess data-shortcode-slide
      data-background-image="https://i.vas3k.ru/7w1.jpg"
      data-background-size="60%"
      data-background-transition="concave">
  
</section><section>


<section data-shortcode-section>
<h4 id="exemple-dapprentissage-supervisé-">Exemple d&rsquo;apprentissage supervisé :</h4>
<h2 id="algorithme-des-kbrplus-proches-voisins">Algorithme des K<br>plus proches voisins</h2>
</section><section>
<p>KNN est un algorithme d’<strong>apprentissage supervisé</strong> cela signifie que l’algorithme nécessite<br>des données classifiées en amont qui vont lui servir à trouver la bonne étiquette pour<br>d’autres données non encore classifiées.</p>
</section><section>
<p>Suivant la nature de l’étiquette, KNN peut servir à :</p>
<ul>
<li>une classification des nouvelles données<br>si les étiquettes sont des catagories ;</li>
<li>une régression si les étiquettes<br>sont des nombres.</li>
</ul>
</section><section>
<p>KNN enregistre, dans un premier temps, tous les points de données étiquetées qui vont lui servir à l&rsquo;apprentissage (c&rsquo;est le training set).</p>
<p>Puis, quand arrive un point de donnée non étiqueté, l&rsquo;algorithme calcule sa distance aux autres points et sélectionne les <strong>k</strong> plus proches.</p>
<p>On a alors deux cas possibles :</p>
</section><section>
<ul>
<li>
<p>si les étiquettes sont des catégories, l&rsquo;algorithme calcule <strong>le mode</strong> des catégories des voisins sélectionnés (catégorie la plus représentée).</p>
</li>
<li>
<p>si les étiquettes sont des nombres, l&rsquo;algorithme calcule <strong>la moyenne</strong> des étiquettes des voisins sélectionnés.</p>
</li>
</ul>
</section><section>
<p>Dans l&rsquo;animation suivante, on utilise KNN pour répondre à la question suivante :</p>
<p>Quelle est la couleur du nouveau point ?</p>
</section>
<section data-noprocess data-shortcode-slide
      data-background-size="100%"
      data-background-transition="concave"
      data-background-video="/knnvid.mp4">
</section><section>
<p>L&rsquo;algorithme des <em>k</em> plus proches voisins<br>est <strong>non paramétrique</strong>.</p>
<p>Aucun modèle mathématique de classification ou régression n&rsquo;est construit à partir des données<br>(pas de paramètre à ajuster).</p>
<p>Les données d&rsquo;apprentissage<br>sont enregistrées telles quelles.</p>
</section><section>
<p>Cela signifie qu&rsquo;on ne présuppose rien de particulier sur les données (à part que des points proches appartiennent à la même catégorie).</p>
<p>L&rsquo;algorithme est donc particulièrement<br>robuste (les données parlent d&rsquo;elles-même)<br>et simple à mettre à jour (suffit d&rsquo;ajouter<br>les nouvelles données d&rsquo;apprentissage).</p>
</section><section>
<p>Le <strong>choix de k</strong> modifie le résultat obtenu.</p>
<ul>
<li>Si <em>k</em> est trop petit, le moyennage est faible et donc la variabilité va être très grande. On parle alors de surapprentissage (<strong>overfitting</strong>).</li>
</ul>
</section><section>
<ul>
<li>En augmentant <em>k</em>, les résultats obtenus se stabilisent (vote de la majorité) et les erreurs diminuent, jusqu&rsquo;au moment où la boule à l&rsquo;intérieur de laquelle se fait le moyennage devient trop grosse, amenant in fine l&rsquo;algorithme a choisir systématiquement la catégorie majoritaire, quel que soit le point&hellip; On augmente alors le <strong>biais</strong> (ici, le biais est le préjudice en faveur du plus grand nombre). L&rsquo;ajustement ne suit plus les variations, on parle de sous-apprentissage (<strong>underfitting</strong>).</li>
</ul>
</section>
<section data-noprocess data-shortcode-slide
      data-background-image="/tabloverfit.png"
      data-background-size="90%"
      data-background-transition="concave">
</section><section>
<p>Le choix de <em>k</em> est donc affaire de compromis. Pour le rendre plus scientifique, on peut chercher à mesurer la performance de l&rsquo;algorithme pour différentes valeurs de <em>k</em>.</p>
<p>Mais comment mesure-t-on la <strong>performance d&rsquo;un algorithme d&rsquo;apprentissage automatique</strong> ?</p>
</section><section>
<p>La <strong>matrice de confusion</strong> permet d&rsquo;évaluer<br>la qualité des prédictions d&rsquo;un algorithme.</p>
<p>Utilisons KNN sur une banque d&rsquo;images de chiffres écrits à la main et concentrons-nous sur<br>sa capacité à reconnaître des &ldquo;3&rdquo;.</p>
</section>
<section data-noprocess data-shortcode-slide
      data-background-image="/MnistExamples.png"
      data-background-size="70%"
      data-background-transition="concave">
</section>
<section data-noprocess data-shortcode-slide
      data-background-image="/matconfus.png"
      data-background-size="60%"
      data-background-transition="concave">
</section><section>
<p>Un algorithme peut très bien être <strong>très précis</strong><br>(les prédictions positives sont bien des 3),<br>mais <strong>peu sensible</strong>, avec un faible taux de rappel (parmi tous les 3, peu ont été identifiés).</p>
</section><section>
<p>À l&rsquo;inverse, on peut avoir une <strong>bonne sensibilité</strong><br>(la plupart des vrais 3 ont été identifiés comme tel), mais <strong>peu précis</strong> (beaucoup de chiffres identifiés comme des 3 sont en fait d&rsquo;autres chiffres).</p>

</section>
</section><section>


<section data-shortcode-section>
<h4 id="exemple-dapprentissage-non-supervisé-">Exemple d&rsquo;apprentissage non-supervisé :</h4>
<h2 id="algorithme-desbrk-moyennes">Algorithme des<br>K-moyennes</h2>
</section><section>
<p>L&rsquo;algorithme des k-moyennes regroupe<br>en catégories des données<br><em>dont on ne connaît rien a priori</em>.</p>
<br>
<p>C&rsquo;est un algorithme<br>de <strong>partitionnement</strong><br>des données (clustering).</p>
</section><section>
<p>L&rsquo;algorithme depend d&rsquo;un seul paramètre<br>(en plus des données) :<br>le nombre de partitions <em>k</em>.</p>
</section><section>
<ul>
<li>
<p>On commence par choisir <em>k</em> points au hasard dans l&rsquo;espace des données (il peut s&rsquo;agir de <em>k</em> points de données ou de <em>k</em> autres points). Ce sont les <em>k</em> centres (ou centroïdes).</p>
</li>
<li>
<p>On attribue ensuite à chaque centre tous les points de données qui lui sont le plus proches, formant ainsi <em>k</em> groupes.</p>
</li>
<li>
<p>Enfin, on déplace chaque centre au barycentre de son groupe.</p>
</li>
</ul>
</section><section>
<p>On répète les deux dernières opérations (attribution des points les plus près<br>et déplacement des centres)<br>tant que les centres bougent<br>d&rsquo;une itération à l&rsquo;autre.</p>
</section>
<section data-noprocess data-shortcode-slide
      data-background-size="100%"
      data-background-transition="concave"
      data-background-video="/vidkmean.mp4">
</section><section>
<p>L&rsquo;algorithme vise à résoudre au final un problème d&rsquo;optimisation ; son but est en effet de trouver le minimum de la distance entre les points à l&rsquo;intérieur de chaque partition.</p>
</section><section>
<p>Mathématiquement, étant donné un ensemble<br>de points $(x_1,x_2,\ldots,x_n)$, on cherche à partitionner les $n$ points en $k$ ensembles $S=\{S_1,S_2,\ldots,S_k\}$ en minimisant la grandeur
$$I = \sum_{i=1}^{k}\sum_{x_j \in S_i}||x_i-\mu_i||^2$$
où $\mu_i$ est le barycentre des points dans $S_i$.</p>
<p>$I$ est la variance intra-classe ou <strong>inertie</strong> intra-classe (terme surtout utilisé en anglais).</p>
</section><section>
<h3 id="choix-de-k">Choix de k</h3>
</section>
<section data-noprocess data-shortcode-slide
      data-background-image="/choixdek.png"
      data-background-size="100%"
      data-background-transition="concave">
</section>
<section data-noprocess data-shortcode-slide
      data-background-image="/inertiefctk3.png"
      data-background-size="80%"
      data-background-transition="concave">
</section>
<section data-noprocess data-shortcode-slide
      data-background-image="/inertiefctk5.png"
      data-background-size="100%"
      data-background-transition="concave">
</section><section>
<h3 id="limites">Limites</h3>
</section>
<section data-noprocess data-shortcode-slide
      data-background-image="/localglobal.png"
      data-background-size="60%"
      data-background-transition="concave">
</section>
<section data-noprocess data-shortcode-slide
      data-background-image="/subopti.png"
      data-background-size="26%"
      data-background-transition="concave">

</section>
</section><section>


<section data-shortcode-section>
<h2 id="jeux-daccessibilitébrsur-un-graphe">Jeux d&rsquo;accessibilité<br>sur un graphe</h2>
<p>On quitte l&rsquo;apprentissage automatique<br>mais on reste dans le champ de l&rsquo;IA.</p>
</section><section>
<p><u>Vocabulaire</u></p>
<p>On entendra ici par jeu :</p>
<ul>
<li>des jeux à deux joueurs<br>($J_1$ et $J_2$ ou Eve et Adam)</li>
<li>à <strong>information complète</strong> : les deux joueurs savent tout (pas comme aux cartes)</li>
<li><strong>alternés</strong> (pas comme à chifoumi)</li>
<li><strong>non randomisés</strong> (pas de hasard)</li>
</ul>
</section><section>
<p>L'<strong>arène</strong> dans laquelle le jeu prend place<br>est un <strong>graphe orienté biparti</strong>.</p>
<div style="color:gray;text-align:left">
Un graphe biparti (ou bipartite) $G$ est un graphe dont l'ensemble des sommets peut être divisé en deux sous-ensembles de sommets disjoints $S_1$ et $S_2$ ($S_1$ et $S_2$ sont une partition de $S$&nbsp;: $S_1\cup S_2=S$, $S_1\cap S_2=\varnothing$) tels que chaque arête de $G$ a une extrémité dans $S_1$ et l'autre dans $S_2$.
</div>
</section>
<section data-noprocess data-shortcode-slide
      data-background-image="/animbipar.gif"
      data-background-size="100%"
      data-background-transition="concave">
</section><section>
<p>Deux joueurs, $J_1$ et $J_2$, s&rsquo;affrontent sur un graphe orienté biparti $G=(S,A)$ où $S$ est constitué des sommets contrôlés par le joueur 1, $S_1$, et de ceux contrôlés par le joueur 2, $S_2$. Chaque sommet est une position valide du jeu et chaque arête est un mouvement autorisé entre ces positions.</p>
</section><section>
<p>Dans le cas d&rsquo;un <strong>jeu d&rsquo;accessibilité</strong>, on attribue à chaque joueur un sous-ensemble de sommets correspondant à des états gagnants qu&rsquo;il doit atteindre pour&hellip; gagner.</p>
<p>Il peut aussi exister un sous-ensemble de sommets correspondant à des états de partie nulle.</p>
</section><section>
<p>Un jeu d&rsquo;accessibilité est alors défini<br>par un quadruplet $(G,S_1,S_2,F)$</p>
<p>où $(G,S_1,S_2)$ est une arène et $F$ est l&rsquo;ensemble des sommets gagnants pour $J_1$.</p>
</section><section>
<h3 id="exemples">Exemples</h3>
</section>
<section data-noprocess data-shortcode-slide
      data-background-size="100%"
      data-background-transition="concave"
      data-background-video="/chompintro.mp4">
</section>
<section data-noprocess data-shortcode-slide
      data-background-image="/arenechomp.png"
      data-background-size="60%"
      data-background-transition="concave">
</section><section>
<p><strong>Autre variante du jeu de Nim :</strong></p>
<p>Eve joue en premier et peut retirer autant d’allumettes qu’elle le souhaite dans un tas<br>du moment qu’elle en prend au moins une<br>et qu’elle en laisse au moins une.</p>
</section><section>
<p>C’est ensuite au tour d’Adam de retirer des allumettes avec pour tous les tours qui suivent<br>une contrainte supplémentaire :</p>
<p>on ne peut pas retirer plus de deux fois le nombre d’allumettes prises par son adversaire<br>au tour précédent.</p>
</section><section>
<p>Le joueur qui retire la dernière allumette gagne.<br>Il n’y a pas de match nul.</p>
</section><section>
<p>En commençant avec un tas de 5 allumettes,<br>on obtient l&rsquo;arène suivante</p>
<p>où chaque sommet est étiqueté par le couple<br>(nombre d&rsquo;allumettes présentes,<br>nombre d&rsquo;allumettes prenables).</p>
</section>
<section data-noprocess data-shortcode-slide
      data-background-image="/variantenim.png"
      data-background-size="60%"
      data-background-transition="concave">
</section><section>
<p>L&rsquo;arène s&rsquo;écrit donc :</p>
<p>$$
\begin{aligned}
&amp;(G,\color{blue}\{(5,4,0),(3,2,0),(2,2,0),(1,1,0),(0,0,0)\}\color{black},\\<br>
&amp;\color{magenta}\{(4,2,1),(3,3,1),(2,2,1),(1,1,1),(0,0,1)\}\color{black},\color{orange}(0,0,1)\color{black})
\end{aligned}
$$</p>
</section><section>
<p><u>Remarque</u></p>
<p>Tout jeu impartial à deux joueurs est une variante du jeu de Nim (théorème de Sprague-Grundy).</p>
</section><section>
<div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
  <iframe src="https://www.youtube.com/embed/2jahbr5wMHk" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" allowfullscreen title="YouTube Video"></iframe>
</div>
</section><section>
<p>Un <strong>jeu impartial</strong> est un jeu tour par tour dans lequel les coups autorisés, ainsi que les gains obtenus, dépendent uniquement de la position,<br>et pas du joueur dont c&rsquo;est le tour.</p>
<p>Un jeu qui n&rsquo;est pas impartial est appelé <strong>jeu partisan</strong> (le morpion ou les échecs par exemple).</p>
</section><section>
<p><strong>Le morpion :</strong></p>
<p>On part ici d&rsquo;une partie avancée.</p>
<p>Eve a les ronds et c&rsquo;est son tour.</p>
</section>
<section data-noprocess data-shortcode-slide
      data-background-image="/graphetictac1.png"
      data-background-size="60%"
      data-background-transition="concave">
</section><section>
<h3 id="mise-au-point-dune-stratégie-gagnante-pour-eve">Mise au point d&rsquo;une stratégie gagnante pour Eve</h3>
</section><section>
<p>Il faut pouvoir s&rsquo;assurer qu&rsquo;Eve arrive sur $F$.</p>
<p>Comment faire ?</p>
</section><section>
<p><strong>Positions gagnantes et attracteurs</strong></p>
<p>Pour déterminer l&rsquo;ensemble des positions gagnantes pour Eve sur l&rsquo;arène, on travaille récursivement depuis les sommets de $F$<br>en suivant les deux préceptes suivants :</p>
</section>
<section data-noprocess data-shortcode-slide
      data-background-image="/sommetgagnant1.png"
      data-background-size="20%"
      data-background-transition="concave">
<ul>
<li>un sommet d&rsquo;Eve est gagnant si <strong>un</strong> de ses arcs sortants le lie à un sommet gagnant.<br>
Eve n&rsquo;a alors plus qu&rsquo;à emprunter ce chemin.<br></li>
</ul>
<p><br><br><br><br><br><br></p>
</section>
<section data-noprocess data-shortcode-slide
      data-background-image="/sommetgagnant2.png"
      data-background-size="20%"
      data-background-transition="concave">
<ul>
<li>un sommet d&rsquo;Adam est gagnant (pour Eve)<br>si <strong>tous</strong> ses arcs sortants le lie à un sommet gagnant.<br>
En effet, Adam ne peut alors pas éviter de mettre Eve dans une position gagnante.</li>
</ul>
<p><br><br><br><br><br><br></p>
</section><section>
<p>Formalisons en définissant la suite $Attr_i(F)$<br>qui contient l&rsquo;ensemble des sommets<br>gagnants après $i$ étapes :</p>
<p>$$ \begin{array}{lll} Attr_0(F) &amp;= &amp;F \\  Attr_{i+1}(F) &amp;= &amp;Attr_{i}(F) \\ &amp;&amp;\cup \{s \in S_1|Succ(s)\cap Attr_i(F) ≠ \varnothing \} \\ &amp;&amp;\cup \{s\in S_2| Succ(s)\subseteq Attr_i(F)\} \end{array} $$</p>
</section><section>
<p>Étant donné que $Attr_i(F) \subseteq Attr_{i+1}(F) \subseteq S$, pour tout $i≥0$, si on suppose le graphe fini,<br>la suite est croissante et bornée<br>et donc stationnaire<br>(à partir d&rsquo;un certain $i=i_0$,<br>$Attr_i(F)$ est constante).</p>
<p>Et si $|G|=n$, $i_0$ vaut au plus $n-1$.</p>
</section><section>
<p>On appelle <strong>attracteur</strong> de $F$ pour le joueur $J_1$<br> la limite de $Attr_i(F)$.</p>
<p>On le note $Attr(F)$.</p>
<p>Tout sommet dans l&rsquo;attracteur<br>est une <strong>position gagnante</strong> pour $J_1$.</p>
</section><section>
<p>Le complémentaire d&rsquo;un attracteur<br>est appelé <strong>piège</strong>.</p>
</section><section>
<p>Si le joueur 1 est sur une position n&rsquo;appartenant pas à son attracteur (et appartenant<br>donc à son piège), cela signifie que :</p>
<ul>
<li>si c&rsquo;est son tour, tous les mouvements possibles restent dans le piège,</li>
<li>si c&rsquo;est le tour de l&rsquo;adversaire, celui-ci a toujours au moins une possibilité de laisser le joueur 1 dans le piège.</li>
</ul>
<p>Cette position est donc perdante&hellip;</p>
</section>
<section data-noprocess data-shortcode-slide
      data-background-size="100%"
      data-background-transition="concave"
      data-background-video="/chompattract.mp4">
</section><section>
<p>Dans le cas de la variante de Nim, l&rsquo;attracteur se réduit à $Attr(G) = \{(0,0,1) , (1,1,0) , (2,2,0) \}$</p>
<p>Le sommet de départ $(5,4,0)$ n&rsquo;est pas dedans<br>$\Rightarrow$ c&rsquo;est perdu pour Eve 😭.</p>
</section>
<section data-noprocess data-shortcode-slide
      data-background-image="/nimvarattr.png"
      data-background-size="70%"
      data-background-transition="concave">
</section><section>
<p>Sur l&rsquo;exemple du morpion, l&rsquo;attracteur contient<br>13 sommets dont celui de départ 🥳.</p>
</section>
<section data-noprocess data-shortcode-slide
      data-background-size="100%"
      data-background-transition="concave"
      data-background-video="/morpionattr.mp4">
</section><section>
<p><strong>Programme permettant de calculer l&rsquo;attracteur</strong></p>
</section><section>
<p>On peut écrire un programme récursif calculant l&rsquo;attracteur en temps linéaire en $|S | + |A|$ <br>(le parcours complet d&rsquo;un graphe est au mieux en $O(|S | + |A|)$ car cela correspond à parcourir<br>les $|S|$ sommets et les $|A|$ arêtes).</p>
<p>Pour éviter de calculer plusieurs fois le même élément, l&rsquo;algorithme tient à jour, pour chaque sommet $s$, un compteur <code>n</code> des successeurs non encore inspectés (sous la forme d&rsquo;un dictionnaire) .</p>
</section><section>
<pre><code class="language-python">def attracteur(G: dict, F: list) -&gt; list:
    &quot;&quot;&quot;
    préconditions : G est est un graphe sous forme de liste d'adjacence implémentée par un dictionnaire
                    F est la liste des sommets gagnants pour le joueur 1
    postcondition : la fonction retourne l'attracteur de F pour le joueur 1 sous forme d'un dictionnaire
                    dont les clés sont les sommets de G et les valeurs True ou False suivant que le sommet appartienne ou non à l'attracteur
    &quot;&quot;&quot;
    Pred = inverseGraphe(G)
    n = {s:len(G[s]) for s in G}
    Attr = {s:False for s in G}
    for sommet in F :
        Joueur1 = True
        propage(sommet,Joueur1,Attr,Pred,n)
    return Attr

def propage(sommet,Joueur1,Attr,Pred,n) :
    if Attr[sommet] :
        return
    Attr[sommet] = True
    for s in Pred[sommet] :
        n[s] -= 1
        if Joueur1 or (n[s] == 0) :
            propage(s,not Joueur1,Attr,Pred,n)
</code></pre>
</section><section>
<h3 id="stratégie-sans-mémoire-gagnante">Stratégie sans mémoire gagnante</h3>
</section><section>
<p>Une <strong>stratégie sans mémoire</strong> est une fonction $\sigma$ qui assigne un mouvement autorisé à un joueur pour chaque position non terminale : $\forall s\in S, (s,\sigma(s))\in A.$</p>
<p>Un joueur sur une position $s$ suit une stratégie s&rsquo;il emprunte le chemin $&lt;s,\sigma(s),\sigma^2(s),\ldots&gt;$.</p>
<p>Elle est dite <strong>sans mémoire</strong> car pour une position donnée, la stratégie est indépendante du chemin qui y a mené ($\sigma$ ne dépend que du sommet).</p>
</section><section>
<p>Une <strong>stratégie sans mémoire gagnante</strong> depuis une position donnée garantit la victoire au joueur en un nombre de coups limité.</p>
<p>Pour le joueur 1, une stratégie gagnante garantit d&rsquo;arriver sur un sommet de $F$.</p>
<p>Mais suivant la position de départ, une telle stratégie n&rsquo;existe pas forcément&hellip;</p>
</section><section>
<p>En construisant l&rsquo;attracteur,<br>on répond à notre première question :</p>
<p>La <strong>position</strong> d&rsquo;Eve est-elle <strong>gagnante</strong> ?<br>$\rightarrow$ Il suffit de vérifier qu&rsquo;elle<br><strong>appartient à l&rsquo;attracteur</strong>.</p>
<p>Si c&rsquo;est le cas, une stratégie gagnante est facile à mettre en place ; il faut faire en sorte que chaque déplacement sur le graphe (chaque coup joué) se fasse vers un sommet de l&rsquo;attracteur. Chaque coup d&rsquo;Eve vers un sommet de l&rsquo;attracteur piège aussi le coup suivant d&rsquo;Adam dans l&rsquo;attracteur.</p>
</section><section>
<p>Comme son nom l&rsquo;indique, l&rsquo;attracteur attire irrémédiablement vers $F$,<br>assurant la victoire<br> au joueur 1.</p>
</section><section>
<p>Le joueur 2 aussi, bien sûr, a son attracteur,<br>et il appartient au complémentaire de l&rsquo;attracteur du joueur 1, piège du joueur 1.</p>
<p>Donc un seul écart du joueur 1 en dehors de son attracteur, et s&rsquo;en est fini pour lui, le joueur 2 peut le condanner à rester dans le piège.</p>
</section><section>
<ul>
<li>Pour Chomp, le joueur 1 appartient à l&rsquo;attracteur, ce qui signifie que sa position de départ est gagnante. Par conséquent, il a une stratégie gagnante. Mais attention à ne pas se tromper au début ! Sur 5 mouvements possibles, le seul assurant la victoire est de manger le carré en haut à droite.</li>
</ul>
</section><section>
<ul>
<li>
<p>Pour la variante de Nim, c&rsquo;est foutu ! Quelle que soit notre stratégie, elle sera perdante&hellip;</p>
</li>
<li>
<p>Enfin, pour le morpion, la victoire tend les bras au joueur 1. Et, sans surprise, son premier mouvement doit être de prendre<br>le milieu.</p>
</li>
</ul>

</section>
</section><section>


<section data-shortcode-section>
<h2 id="algorithme-du-minimax">Algorithme du minimax</h2>
</section><section>
<p>Algorithme star pour les jeux. C&rsquo;est ce type d&rsquo;algorithme que Deep Blue a utilisé<br>pour battre  Kasaparov en 1997.</p>
</section>
<section data-noprocess data-shortcode-slide
      data-background-image="/Kasparov.png"
      data-background-size="contain"
      data-background-transition="concave">
</section><section>
<p>Le principe de l&rsquo;algo est proche de celui de l&rsquo;attracteur, mais il est plus souple et permet surtout de n&rsquo;explorer qu&rsquo;une petite partie de l&rsquo;arène (au détriment de sa performance).</p>
</section><section>
<p>Le plus grand changement par rapport au raisonnement sur l&rsquo;attracteur : on transforme<br>le graphe de l&rsquo;arêne en <strong>arbre</strong>.</p>
</section>
<section data-noprocess data-shortcode-slide
      data-background-image="/morpionarbre.png"
      data-background-size="contain"
      data-background-transition="concave">
</section><section>
<ul>
<li>
<p>Avantage ?</p>
</li>
<li>
<p>Inconvénient ?</p>
</li>
</ul>
</section><section>
<p>Le but va être de trouver un chemin entre la racine de l&rsquo;arbre et une feuille gagnante (victoire finale).</p>
</section><section>
<p>L&rsquo;idée est, comme pour l&rsquo;attracteur,<br>de partir de la situation finale et de remonter récursivement tour par tour.</p>
<p>On score chaque feuille terminale<br>avec une valeur de $+\infty$ si le joueur 1 gagne<br>et de $-\infty$ si c&rsquo;est le joueur 2.</p>
</section><section>
<p>On remonte ensuite niveau par niveau :</p>
<ul>
<li>si c&rsquo;est le tour du joueur 1, on choisi le sommet au plus grand score (<strong>max</strong>)</li>
<li>si c&rsquo;est au joueur 2, on choisi le sommet au plus petit score (<strong>min</strong>)</li>
</ul>
<p>Chaque joueur simulé joue bien ainsi<br>de manière optimale.</p>
</section><section>
<p>L&rsquo;intérêt majeur de minimax est la possibilité<br>de partir de n&rsquo;importe quel niveau<br>et pas seulement des positions finales !</p>
<p>On peut donce se contenter de  regarder<br>seulement quelques coups à l&rsquo;avance.</p>
<br>
<p><span class='fragment ' ><span style="font-weight:normal">Quel est l’intérêt ?</span></span></p>
</section><section>
<p>Mais pour se limiter à une certaine profondeur dans l&rsquo;arbre, il faut pouvoir scorer<br>les sommets du niveau de départ !</p>
<br>
<p>On utilise alors une <strong>heuristique</strong>.</p>
</section><section>
<div style="display: flex;justify-content: center;">
<div style = "border:solid red 5px;padding: 20px 0px 30px 0px; font-size:40px">
Une heuristique est une méthode de calcul qui fournit rapidement une solution réalisable,<br><span>pas nécessairement optimale ou exacte</span>,<br>pour un problème d’optimisation difficile.<br>
Une heuristique est donc un compromis entre d’un côté l’optimalité (trouver la meilleure solution) et/ou la complétude (trouver toutes les solutions) de l’algorithme et de l’autre côté sa vitesse.
</div></div>
</section><section>
<p>Exemples :</p>
<p>Au morpion, si c&rsquo;est au tour du joueur 1, on peut compter le nombre de diagonales encore possibles pour le joueur 1 et soustraire le nombre de celles encore possibles pour le joueur 2.</p>
</section>
<section data-noprocess data-shortcode-slide
      data-background-size="100%"
      data-background-transition="concave"
      data-background-video="/gifmorp.mp4">
</section><section>
<iframe src="https://trinket.io/embed/python/5a7f499742?start=result" width="100%" height="600" frameborder="0" marginwidth="0" marginheight="0" allowfullscreen></iframe>
</section><section>
<p>L&rsquo;arbre total du morpion n&rsquo;est pas si gros :<br>le <strong>facteur de ramification</strong> $b$ est de 5 en moyenne et il y a au plus 9 niveaux (9 coups),<br>ce qui donne $\approx 5^9 = 1\,953\,125$</p>
<p>Aux échecs, $b\approx35$ et un partie dure en moyenne 100 coups, ce qui donne $b^m\approx10^{54}$<br>sommets à inspecter&hellip;</p>
</section><section>
<p>Minimax inspecte en réalité environ 4 fois moins de sommets que les deux millions prédits (beaucoup de parties se terminent<br>avant le neuvième coup).</p>
</section><section>
<p>Il en inspecte néanmoins beaucoup trop puisqu&rsquo;il n&rsquo;y a que $9!=362\,880$ coups possibles<br>si l&rsquo;ordi commence.</p>
<p>Cela illustre le fait qu&rsquo;un arbre contient beaucoup de sommets redondants par rapport au graphe<br>du jeu dont il est tiré (c&rsquo;est le prix à payer<br>pour casser les cycles).</p>

</section>
</section><section>


<section data-shortcode-section>
<h2 id="problème-du-sac-à-dos">Problème du sac-à-dos</h2>
</section><section>
<p>Le problème du sac-à-dos est<br>un probème clé d&rsquo;optimisation.</p>
<p>Il s&rsquo;agit de choisir des objets ayant une certaine valeur et un certain poids pour les mettre dans<br>un sac ayant une capacité maximum<br>(un poids à ne pas dépasser).</p>
<p>On souhaite obtenir le sac de plus grande valeur.</p>
</section><section>
<p>On ne s&rsquo;occupe ici que de la version la plus simple du problème dite <strong>knapsack 0-1</strong> où un objet est soit présent une seule fois dans le sac, soit absent.</p>
</section><section>
<p>Le problème du sac-à-dos est un problème d&rsquo;optimisation sous contrainte et une foule de défis scientifiques et industriels peuvent se mettre sous cette forme. Son importance est colossale.</p>
</section><section>
<p>Supposons que l&rsquo;on ait $n$ objets.</p>
<p>Un algorithme force brute consiste<br>à étudier les &hellip; possibilités.</p>
<p>Et dès qu&rsquo;il s&rsquo;agit d&rsquo;explorer un ensemble de combinaisons, la récursivité est l&rsquo;outil de choix.</p>
</section><section>
<p>Supposons que l&rsquo;on cherche à placer les objets suivants dans un sac de capacité 900.</p>
<table>
<thead>
<tr>
<th>objets</th>
<th style="text-align:center">🥏</th>
<th style="text-align:center">🎺</th>
<th style="text-align:center">🥊</th>
<th style="text-align:center">🧸</th>
<th style="text-align:center">🪠</th>
<th style="text-align:center">⏰</th>
</tr>
</thead>
<tbody>
<tr>
<td>valeurs $v$</td>
<td style="text-align:center">5</td>
<td style="text-align:center">50</td>
<td style="text-align:center">65</td>
<td style="text-align:center">20</td>
<td style="text-align:center">10</td>
<td style="text-align:center">12</td>
</tr>
<tr>
<td>poids $p$</td>
<td style="text-align:center">320</td>
<td style="text-align:center">700</td>
<td style="text-align:center">845</td>
<td style="text-align:center">180</td>
<td style="text-align:center">70</td>
<td style="text-align:center">420</td>
</tr>
</tbody>
</table>
</section>
<section data-noprocess data-shortcode-slide
      data-background-image="/arbresac.png"
      data-background-size="contain"
      data-background-transition="concave">
</section><section>
<pre><code class="language-python">def KS(v,p,c,i,valeur,poids):
    n = len(v)
    if i == n: # cas de base (i = n-ième objet)
        if poids &gt; c:
            return 0
        else:
            return valeur
    else:
        valeurAvec = valeur + v[i]
        poidsAvec = poids + p[i]
        return max(KS(v,p,c,i+1,valeur,poids),KS(v,p,c,i+1,valeurAvec,poidsAvec))
</code></pre>
</section>
<section data-noprocess data-shortcode-slide
      data-background-image="/arbresacsol.png"
      data-background-size="contain"
      data-background-transition="concave">
</section><section>
<p>C&rsquo;est bien sûr trop long si le nombre<br>d&rsquo;objets devient conséquent.</p>
<p>Pour accélérer les choses, on peut se tourner vers une <strong>stratégie gloutonne</strong> (stratégie étape par étape où un critère de classement permet de sélectionner le prochain objet à ajouter).</p>
<p>La complexité devient alors &hellip;</p>
</section><section>
<p>Le ratio valeur/poids de chaque objet<br>semble un bon critère.</p>
<table>
<thead>
<tr>
<th>objets</th>
<th style="text-align:center">🥏</th>
<th style="text-align:center">🎺</th>
<th style="text-align:center">🥊</th>
<th style="text-align:center">🧸</th>
<th style="text-align:center">🪠</th>
<th style="text-align:center">⏰</th>
</tr>
</thead>
<tbody>
<tr>
<td>ratio $v/p$</td>
<td style="text-align:center">1/64</td>
<td style="text-align:center">1/14</td>
<td style="text-align:center">1/13</td>
<td style="text-align:center">1/9</td>
<td style="text-align:center">1/7</td>
<td style="text-align:center">1/35</td>
</tr>
</tbody>
</table>
</section><section>
<p>Problème : ça ne marche pas forcément&hellip;</p>
<p>Ici, on se retrouve avec 🪠 et 🧸 dans le sac<br>pour une valeur de 30€ ce qui n&rsquo;est<br>évidemment pas optimal.</p>
</section><section>
<p>Une autre démarche consiste à construire l&rsquo;abre binaire comme pour l&rsquo;approche force brute mais en l&rsquo;élaguant au fur et à mesure quand des branches ne peuvent plus donner la solution.</p>
<p>C&rsquo;est la méthode  “séparation et évaluation”<br>(branch and bond ou BB en anglais).</p>
</section><section>
<p>Ici, deux élagages possibles :</p>
<ul>
<li>lorsque tout objet ajouté dépasse la capacité, pas la peine d&rsquo;aller plus loin.</li>
<li>et si la valeur maximale du sous-arbre est inférieure à la valeur trouvée par l&rsquo;approche gloutonne, pas la peine non plus d&rsquo;aller plus loin.</li>
</ul>
<p>On se sert donc ici de l&rsquo;approche gloutonne<br>comme d&rsquo;une &hellip;</p>
</section>
<section data-noprocess data-shortcode-slide
      data-background-image="/arbresacbb.png"
      data-background-size="contain"
      data-background-transition="concave">

</section>
</section><section>
<p><a href="https://info-tsi-vieljeux.github.io/semestre_3/tp13/">Retour site</a></p>
</section>

  


</div>
      

    </div>
<script type="text/javascript" src=/reveal-hugo/object-assign.js></script>

<a href="/reveal-js/css/print/" id="print-location" style="display: none;"></a>
<script type="text/javascript">
  var printLocationElement = document.getElementById('print-location');
  var link = document.createElement('link');
  link.rel = 'stylesheet';
  link.type = 'text/css';
  link.href = printLocationElement.href + (window.location.search.match(/print-pdf/gi) ? 'pdf.css' : 'paper.css');
  document.getElementsByTagName('head')[0].appendChild(link);
</script>

<script type="application/json" id="reveal-hugo-site-params">{"highlight_theme":"github-dark","line-numbers":true,"theme":"sky","transition":"concave","transition_speed":"fast"}</script>
<script type="application/json" id="reveal-hugo-page-params">{"highlight_theme":"atom-one-dark-reasonable"}</script>

<script src="/reveal-js/js/reveal.js"></script>

<script type="text/javascript">
  
  
  function camelize(map) {
    if (map) {
      Object.keys(map).forEach(function(k) {
        newK = k.replace(/(\_\w)/g, function(m) { return m[1].toUpperCase() });
        if (newK != k) {
          map[newK] = map[k];
          delete map[k];
        }
      });
    }
    return map;
  }
  
  var revealHugoDefaults = { center: true, controls: true, history: true, progress: true, transition: "slide" };
  var revealHugoSiteParams = JSON.parse(document.getElementById('reveal-hugo-site-params').innerHTML);
  var revealHugoPageParams = JSON.parse(document.getElementById('reveal-hugo-page-params').innerHTML);
  
  var options = Object.assign({},
    camelize(revealHugoDefaults),
    camelize(revealHugoSiteParams),
    camelize(revealHugoPageParams));
  Reveal.initialize(options);
</script>


  
  
  <script type="text/javascript" src="/reveal-js/plugin/markdown/marked.js"></script>
  
  <script type="text/javascript" src="/reveal-js/plugin/markdown/markdown.js"></script>
  
  <script type="text/javascript" src="/reveal-js/plugin/highlight/highlight.js"></script>
  
  <script type="text/javascript" src="/reveal-js/plugin/zoom-js/zoom.js"></script>
  
  
  <script type="text/javascript" src="/reveal-js/plugin/notes/notes.js"></script>









  <script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
  <script>
    mermaid.initialize({startOnLoad: false});
    let render = (event) => {
      let mermaidElems = event.currentSlide.querySelectorAll('.mermaid');
      if (!mermaidElems.length){
          return
      }
      mermaidElems.forEach(mermaidElem => {
          let processed = mermaidElem.getAttribute('data-processed');
          if (!processed){
              
              mermaid.init(undefined, mermaidElem);
          }
      });
    };
    Reveal.addEventListener('slidechanged', render);
    Reveal.addEventListener('ready', render);
  </script>

    

<script>
MathJax = {
  tex: {
    inlineMath: [['$', '$'], ['\\(', '\\)']]
  },
  svg: {
    fontCache: 'global'
  }
};
</script>

<script type="text/javascript" id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js">
</script>
    
  </body>
</html>
